#pragma config(Sensor, S1,     bumper,              sensorTouch)
#pragma config(Sensor, S4,     sonar,               sensorSONAR)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "move.c"
#define DESIRED_DISTANCE 20
#define SPEED_DIST_R 1
#define WALL_FOLLOW_R 5

#define SONAR_MAX 80.0

static bool LED_flashing = false;

task LED () {
  while(true) {
    if(SensorValue[bumper]) {
      motor[motorA] = 100;
    } else {
      motor[motorA] = 0;
    }
  }
}

task reverse() {
  motor[motorA] = 100;
  motor[motorB] = -50;
  motor[motorC] = -50;
  time100[T1] = 0;
  while(time100[T1] < 10);
  motor[motorA] = 0;
  stop(0);
}

task bump_detect() {
  while(true) {
    if(SensorValue[bumper]) {
      StartTask(reverse, 255);
    }
  }
}

task sonar_distance() {
  while(true) {
    int speed = -SPEED_DIST_R * (DESIRED_DISTANCE - SensorValue[sonar]);
    motor[motorB] = speed;
    motor[motorC] = speed;
  }
}

task sonar_tone() {
  while(true) {
    PlayTone(10*SensorValue[sonar], 1);
  }
}

task sonar_follow() {

  while(true) {
    nxtDisplayTextLine(1, "%d", SensorValue[sonar]);
    motor[motorB] = 30;
    float actual_dist = (SensorValue[sonar] >= SONAR_MAX) ? SONAR_MAX : SensorValue[sonar];
    int mathsStuff = 30 + (int) (15.0 * sin (PI * ((DESIRED_DISTANCE - actual_dist) / (2.0 * SONAR_MAX))));
    motor[motorC] = 30 + (int) (15.0 * sin (PI * ((DESIRED_DISTANCE - actual_dist) / (2.0 * SONAR_MAX))));
  }
}

task main() {
  nMotorPIDSpeedCtrl[motorA] = mtrNoReg;
  StartTask(bump_detect);
  StartTask(sonar_tone);
  StartTask(sonar_follow);
  while(true);
}
